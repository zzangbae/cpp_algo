## AD-HOC_1 : 탐욕알고리즘

### 동전 거슬러주기

다음 2문제를 확인해보자

> 1, 4, 5 동전을 이용하여 8원을 거슬러주기 위해 필요한 최소 동전의 수를 구하는 프로그램을 작성해보세요.

> 1, 5, 10, 20 동전을 이용하여 78원을 거슬러주기 위해 필요한 최소 동전의 수를 구하는 프로그램을 작성해보세요.

두 문제 모두 큰 동전부터 사용하는 것이 좋아보인다.

첫 번째 문제에 해당 논리를 적용해보면 5 + 1 + 1 + 1이 최선으로 보인다.

하지만 4 + 4로, 4원짜리 동전 2개를 사용하는 것이 정답이다.

두 번째 문제는 위의 논리를 활용해도 된다.

**주어진 동전들이 모두 배수관계**에 놓여있기 때문이다.

따라서 가능한 큰 동전이 사용 가능하다면, 작은 동전을 사용하는 것보다 항상 좋은 선택이된다.

문제 `동전더하기`를 보면 **O(N)**으로 풀 수 있음을 확인할 수 있다.

### 연속부분 합의 최댓값 구하기

다음 문제를 확인해보자

> 다음과 같이 8개의 숫자가 주어졌을 때 특정 구간을 잡아 그 구간 내에 있는 숫자의 합이 최대가 되도록 해보세요. [4, 3, -6, 9, -15, 1, 3, -2]

첫 숫자부터 모든 구간에 대해서 확인하는 방법으로 문제를 풀 수 있겠으나, 숫자가 많아질 수록 비효율적일 수 있다.

이렇게 풀 수 있다.

--> 왼쪽부터 순서대로 구간을 확장시키되, 끊어야 하는 순간 끊어주기

이때, 끊어야 하는 순간은 합이 0보다 작아지는 순간이다.

즉, 위의 예제에서 `4, 3, -6, 9, -15`까지 확장되는 순간 합이 -5가 되어 여기에서 끊고, 다음 원소에서 시작하는 것이 좋다.

이렇게 문제를 풀게 되면 시간 복잡도는 **O(N)**이 되어 빠르게 문제를 해결할 수 있다.

### 쪼개어 배낭 채우기 - 도둑 보석방 문제

>  도둑이 보석방을 털러갔다고 해보자.
>
> 도둑의 가방의 크기는 10이고, 더 많은 무게의 보석들을 담을 수 없다.
>
> 또한, 보석은 종류별로 하나씩 있다.
>
> 보석의 무게와 가격이 주어지고, 도둑은 한정된 가방안에 보석을 담되, 최대한 이익이 되도록 담고자 한다.

가장 먼저 생각나는 것은 가장 무게가 적은 것부터 담는다거나, 가격이 높은 것부터 담는 것이 목표일 것이다. 하지만 이는 최적이 아닌 경우가 많다. 따라서 동적계획법을 이용해야만 해결이 가능하다.

이 때, 보석을 쪼개서 담을 수 있는 경우와 쪼개지 못하는 경우가 있을 수 있다.

쪼개지 못하는 경우는 담거나 담지 않는 문제 -> **0/1 Knapsack 문제**

쪼개서 담을 수 있는 경우 -> **Fractional Knapsack 문제**

보석을 쪼갤 수 있는 경우에는 동적 계획법을 사용하지 않고 문제를 풀 수 있다.

**무게 대비 가격이 높은 보석을 우선적으로 담는 것이 최적**이라고 생각할 수 있다.

즉, 가격/무게 값을 찾고, 내림차순으로 정렬한 후, 배낭의 크기를 넘지 않는 한 순서대로 보석을 담아주는 것이 좋다.

### 숫자합치기

> [1, 8, 3, 10] 4개의 숫자가 주어졌을 때,
>
> 2개의 숫자를 골라 하나의 숫자로 합치는 과정을 단 하나의 숫자가 남을 때까지 반복하려고 한다.
>
> 숫자가 a, b였다면 두 숫자를 합치는데 드는 비용은 a + b
>
> 숫자를 전부 합치기 위해 필요한 최소비용을 구하여라.

그리디 해결 방법

: 순서와 상관없이 가장 작은 2개의 숫자만 계속 선택하는 그리디로 해결이 가능하다.

허프만 코드(Huffman Code)와 유사하다.

매 순간마다 어떤 쌍을 선택해야하는지에 대한 판단이 확실히 서는 경우에도 그리디 알고리즘을 사용하여 문제를 해결할 수 있다.

+ 그렇다면, 어떻게 가장 작은 숫자 2개의 숫자만을 계속해서 선택할까?

  + 매번 sort를 돌리면서 가장 작은 두개를 선택할 수는 있겠지만 이는 quick sort라 가정해도
  + O(N^2logN)이 되게된다. 즉, N이 10만정도면 시간초과가 나게 된다.

+ 해결

  + **우선순위 큐**. 즉, 힙 구조를 활용하면 된다. `priority queue`

  + 우선순위 큐를 이용하면 값을 추가, 삭제하고 최솟값을 찾는데 각각 O(logN)이 소요된다.

  +  for문 한번 돌리게 되면 총 시간복잡도는 O(NlogN)이 된다. 

    -> N이 10만정도일데도 시간초과가 나지 않음

### 회의실 준비

> 하나의 회의실이 있고, n개의 회의 요청이 들어왔다.
>
> 각각 시작시간과 끝시간이 주어진다.
>
> 한 회의가 시작되면 도중에 그만둘 수 없고,
>
> 한 회의가 끝나는 직후에 동시에 다른 회의가 시작될 수 있다.
>
> 적절하게 회의 요청을 수락하여 최대로 많은 회의가 진행되도록하자.

-> 그리디 알고리즘은 여러접근법을 생각하고 해가 적절하게 나오는지 판단하는 것이 우선이다.

1. 회의시간시간을 기준으로 오름차순

   [1, 2], [2, 9], [3, 6], [6, 8]은 시작 시간 기준으로 오름차순 정렬이다. [1, 2], [2, 9]가 답이 되지만, 최적의 답은 [1, 2], [3, 6], [6, 8]이 되므로 반례가 존재

2. 회의 구간의 길이를 기준으로 오름차순

   -> 마찬가지로 반례존재

3. 회의 끝 시간을 기준으로 오름차순 정렬

   -> 정답

* 3번인 이유 : 현재 상황에서 끝나는 시간이 k인 가장 앞선 회의보다 이후 k'시간 때에 끝나는 회의를 선택했을 때, 앞으로 회의에 추가적으로 사용할 수 있는 시간이 항상 더 짧아지기 때문.
* 구현시, 고려사항 - 코드 기반 내용 추가한 부분
  * 시작 시각(s)와 끝 시각(e)가 주어진다.
  * 그러면 우리는 vector<pair<int, int>> 에 하나씩 넣을 것이다.
  * 이 때, e, s 순으로 집어넣으면 sort에 대한 cmp 함수를 굳이 짜줄 필요가 없다. -> 그냥 sort를 돌리면 끝시간에 맞춰서 오름차순이 되게 된다.
  * 또한 전회의의 시작시간과 끝시간을 저장할 필요없이 전 회의의 끝 시간만 저장하면 된다.(메모리 사용을 줄일 수 있음)

### 최대 숫자 만들기

> [43, 39, 444]
>
> 이렇게 3개의 숫자가 주어졌을 때,
>
> 적당한 순서에 맞춰 나열하여 각 숫자들을 붙여 만들 수 있는 숫자 중
>
> 가능한 최댓값을 구하는 프로그램을 작성하여라.

-> 마찬가지로 그리디 접근법으로 가정하고 넣어보기

* 가장 큰 자리부터 봤을 때 더 큰 숫자가 먼저 나오는 숫자를 선택할 수 있도록 하면되지 않을까?

​		-> 444, 43, 39 로부터 4444339를 만드는 것이 가장 좋아보인다.

* 하지만 4와 43이 였다면? 즉, 한 숫자가 다른 숫자의 접두사가 되는 경우에는 어떨까

  -> 4, 43인 경우와 4, 47인 경우는 다르다. 474, 443이렇게 되어야 가장 크다.

  즉, a, b를 정렬할 때, ab, ba 형태로 붙여보고, 값이 더 큰 경우에 해당하는 숫자가 앞으로 나와야한다.

* 구현시 고려해야할 점
  * sort의 cmp로직을 짤 때, to_string으로 ab, ba를 만들어보고 그냥 비교를 하면된다.
  * 왜냐하면 string의 경우, 더 큰 숫자가 더 크기 때문에 그 비굣값을 그냥 가져다 쓰면된다.(사전식)
  * 따라서 길이에 맞춰서 잘라 다시 int나 long long 형으로 바꿔서 비교할 필요가 없다.
  * 추가적으로 sort의 cmp로직은 일자로 (a, b)가 들어와서 값이 true이면 해당 순서(a -> b 순)가 맞음을 의미하고, false이면 (b -> a순)이 맞음을 의미한다.(맞음에 맞춰서 순서를 조정한다.)